<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Pretty Good Receiving by Robert Moore</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Pretty Good Receiving</h1>
        <h2>Optimizing receiver placement for transmit-only sensor networks</h2>
        <a href="https://github.com/romoore/jun-simulate" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h2>Transmit Only Receiver Placement</h2>

<p>Transmit-Only (TO) sensor networks enable smaller and cheaper sensors,
reduced energy consumption, and simpler over-the-air protocols.  The challenge
in these networks is to ensure that the vast majority (over 99%) of packets
sent from a sensor actually reach a network sink.  To assist in analyzing the
possibilities of receiver placements, this project simulates placing receivers
at various locations within the sensor network in order to minimize lost
packets due to collisions.</p>

<h2>The Algorithm</h2>
<p>ALOHA got it wrong! If you think that colliding transmissions always
cause packet loss, read-up on <a
href="http://en.wikipedia.org/wiki/Capture_effect">the capture effect</a>. So,
given a set of transmitter locations, where is the best place to put your
receivers if you wish to maximize the number of packets captured during a
collision?</p>

<p>The first step, after determining transmitter locations, is to go about calculating the set of
pairwise capture disks for each pair of transmitters.  That is, for each
pair of transmitters in a 2-dimensional plane (t<sub>1</sub>, t<sub>2</sub>), 
the capture disk is the area where a receiver would be able to decode
t<sub>1</sub>'s packet during a collision with t<sub>2</sub>'s packet. The
math to calculate this is beyond the scope of this page, but you can <a
href="https://github.com/romoore/jun-simulate/blob/master/src/main/java/edu/rutgers/winlab/junsim/Main.java">check out
the code</a> for more details.</p>

<p>Once you have your capture disks, you then collect a set of possible
receiver locations as the centers of the disks and the intersections of all
disks.  Then, for each possible solution point, determine how many capture
disks contain that point.  Sort the solution points in non-increasing order of
capture disks, and select the maximum.  Remove this point and its associated
disks and repeat until you've found enough receivers or run out of disks or
solution points.</p>

<h3>Speeding Things Up</h3>
<p>The original algorithm, while provably half-optimal, suffers from the
significant practical drawback of requiring O(n<sup>6</sup>) time complexity
to run.  What this means is that if we want to simulate 100 transmitters
(n &eq; 100), then we may require at most 1 trillion (1x10<sup>12</sup>)
computations.  To explain, 100 transmitters will generate 10,000 capture
disks.  For each disk, it may intersect every other disk, resulting in
100,000,000 solution points.  These solution points must then be compared to
each of the 10,000 disks, resulting in 1,000,000,000,000 comparisons.
This makes the original algorithm impractical for
implementation for any large number of devices (e.g., 1000).</p>

<p>A simple way to reduce the running time is to reduce the number of points
to evaluate, since this is a dominant portion of the time complexity.  A
simple way to do this is to produce a "grid" of fixed points that will be
evaluated during the simulation.  The grid's point density can be adjusted
appropriate to the actual deployment or the radio wavelength being used.  The
option is available using the "grid" or "recursive" algorithm values.  The
"recursive" option uses an adaptive grid search algorithm to identify local
maxima in the search space.</p>


<h2>Compiling</h2>
<p>The code is built most easily with <a href="http://maven.apache.org">Apache
Maven</a>.  In the main directory, just type:
<pre><code>mvn clean package</code></pre>
and the code should compile itself.  If not, send me a message and I'll see if
I can't get it working.

<h2>How to Use</h2>
<p>Once you've compiled the code with maven, your <code>target</code>
directory should have at least 2 JAR archives: with dependencies and without.
The simplest way to execute the application is the jar-with-dependencies
archive.  It takes a single parameter, a configuration file (a <a
href="https://github.com/romoore/jun-simulate/blob/master/src/main/resources/config.xml">sample is
included</a>) which holds the primary runtime parameters.  If your
configuration file is "myconfig.xml", then run the application like this:
<pre><code>java -jar jun-simulate-1.0.0-SNAPSHOT-jar-with-dependencies.jar myconfig.xml</code></pre>
you should see output on the console almost immediately. Two other
configuration files are also used: graphics.xml and log4j.xml.  Graphics.xml
is used to configure graphical options (output images) for the simulation, and
log4j.xml is used to control the logging behavior of the program (at compile
time).</p>

<h3>Main Configuration File</h3>

<p>The configuration file is an XML-based set of runtime parameters. An
example is provided in the source, and this section is a description of each
parameter in more detail.</p>

<dl class="config-file">
  <dt>beta: float</dt>
  <dd>The relative distance between a receiver and pair of
  transmitters.  If the distance between the receiver and each transmitter
  differs by at least this much, then the receiver should be able to capture
  the packet with the stronger signal power.</dd>
  <dt>numTransmitters: integer</dt>
  <dd>The number of transmitter locations to simulate.  <strong>Be careful with
  this value!</strong> Even a small number of transmitters (30) can create a
  very large number of solution points (&gt;400,000).  Be sure your computer
  has sufficient memory and processor resources.  For 50 transmitters, you
  should allocate at least 2GB of RAM to the Java heap.</dd>
  <dt>numReceivers: integer</dt>
  <dd>The maximum number of receivers to place.  The simulator will place 1
  receiver at a time until either no more solution points or capture disks
  remain, or until this limit is reached.</dd>
  <dt>radioPower: float</dt>
  <dd>The transmit power of the transmitters' radios in dBm.Currently unused,
  but in future versions will probably enable the auto-calculation of
  <em>beta</em> if not explicitly provided. </dd>
  <dt>radioAlpha: float</dt>
  <dd>The attenuation constant of the local environment.  Currently unused,
  but in future versions will probably enable the auto-calculation of
  <em>beta</em> if not explicitly provided.</dd>
  <dt>squareWidth: float</dt>
  <dd>The width of the transmitter placement rectangle.</dd>
  <dt>squareHeight: float</dt>
  <dd>The height of the transmitter placement rectangle.</dd>
  <dt>universeWidth: float</dt>
  <dd>The width of the "universe" in which receivers may be placed.  Should be
  greater than <em>squareWidth</em>.</dd>
  <dt>universeHeight: float</dt>
  <dd>The height of the "universe" in which receivers may be placed.  Should
  be greater than <em>squareHeight</em>.</dd>
  <dt>randomSeed: int</dt>
  <dd>A seed for the random number generator.  Allows repeatable experiments.
  The random number generator is used for transmitter coordinate
  generation.</dd>
  <dt>numTrials: integer</dt>
  <dd>The number of simulations to run before computing aggregate
  statistics.</dd>
  <dt>outputFileName: string</dt>
  <dd>The filename of the statistics output file.  The file is written in
  comma-separated values (CSV) format.</dd>
  <dt>numThreads: integer</dt>
  <dd>The number of threads to spawn to perform the simulation.</dd>
  <dt>maxRangeMeters: float</dt>
  <dd>The maximum distance a receiver can receive packets from a transmitter.
  This is applied to the dimensions above, so be sure to use a sensible value
	for your simulation.</dd>
	<dt>experimentType: string</dt>
	<dd>The name of the algorithm to use for the simulated experiment.  Can be
	one of the following options:
	<ul>
		<li>"basic" - The standard algorithm as described above.</li>
		<li>"binned" - A slight optimization of the basic algorithm that ranks
		points and places them into groups based on their scores.</li>
		<li>"grid" - A grid-based algorithm using a fixed set of grid points.
		Described above.</li>
		<li>"recursive" - An adaptive grid-based algorithm that performs localized
		searches for local maxima in the search space.</li>
	</ul>
	</dd>
	<dt>gridDensity: integer</dt>
	<dd>Number of points per "unit" in the standard grid algorithm, or for the
	entire "universe" in the adaptive (recursive) grid algorithm.</dd>
	<dt>randomized: boolean</dt>
	<dd>Whether or not the adaptive grid-based algorithm should use randomized
	grid positions</dd>
	<dt>renderConfig: string</dt>
	<dd>The path to the graphics configuration file (described below).  The path
	can be either absolute or relatie from the working directory.</dd>
	<dt>transmittersFile: string</dt>
	<dd>The filename (and possibly path) for the transmitters file to be used in
	the experiment.  If it exists, it will be used as transmitter position
	inputs, otherwise it will be an output for the random transmitter
	positions.</dd>
	<dt>receiversFile: string</dt>
	<dd>The filename (and possibly path) for the receivers file containing the
	calculated receiver positions for the experiment.</dd>
	<dt>outputBasePath: string</dt>
	<dd>The base path for output files.  Defaults to the working directory if
	not specified.</dd>
</dl>

<h3>Graphics Configuration File</h3>

<p>The graphics configuration file specifies how the application will generate
graphical representations of the simulations.  If enabled, the application
will generate an image (rasterized PNG) after the determination of each
receiver position.  Image files are named numerically, starting with
"1000.png" containing only the transmitter positions, and incrementing by one
for each receiver placed.</p>

<dl>
  <dt>generateImages: boolean</dt>
  <dd>If <em>true</em>, then the simulator will produce PNG files in a
  subdirectory of its working directory according to the parameters it is
  using. The directory name is "sX_tY_xZ" where X is the random seed, Y is the
  number of transmitters, and Z is the trial number.</dd>
  <dt>renderWidth: int</dt>
  <dd>Pixel width of output images.</dd>
  <dt>renderHeight: int</dt>
	<dd>Pixel height of output images.</dd>
	<dt>drawTransmitters: boolean</dt>
	<dd>Flag to enable drawing of transmitter locations in the output
	images.</dd>
	<dt>drawReceivers: boolean</dt>
	<dd>Flag to enable drawing of receiver lcoations in the output images.</dd>
	<dt>drawReceiverLines: boolean</dt>
	<dd>Flag to enable drawing of lines from receiver locations to capture disk
	centers.</dd>
	<dt>drawSolutionPoints: boolean</dt>
	<dd>Flag to draw positions of all possible solutions points in output
	images.</dd>
	<dt>drawLegend: boolean</dt>
	<dd>Flag to draw the solution point ranking histogram and legend on output
	images.</dd>
	<dt>useColorMode: boolean</dt>
	<dd>Flag to enable color output for images.  If false, output images will be
	rendered in grayscale.</dd>
	<dt>drawCaptureDisks: boolean</dt>
	<dd>Flag to draw the capture disks in the output images.</dd>
</dl>

<h2>Screenshots</h2>
<p> The screenshots below are available when the configuration parameter
<code>generateImages</code> is set to <code>true</code>. The simulator will
generate PNG images for each step of the algorithm.</p>

<p>Below is a set of images taken from an example run with 5 transmitters
randomly placed around the area.</p>

<table >
  <tr>
    <td><a href="images/0000.png"><img src="images/0000-tn.png"
    height="225" width="400" ></img></a><p>Arrangement of the
    transmitters within the coordinate plane.</p></td>
    <td><a href="images/0010.png"><img src="images/0010-tn.png" height="225"
    width="400" ></img></a><p>Calculating the capture disks of the
    transmitter pairs. </p></td>
    <td><a href="images/0020.png"><img src="images/0020-tn.png" height="225"
    width="400" ></img></a><p>Generating potential receiver locations
    from the capture disks.</p></td>
    <td><a href="images/1001.png"><img src="images/1001-tn.png" height="225"
    width="400" ></img></a><p>The first receiver is placed.</p></td>
  </tr>
</table>
<table>
  <tr>
    <td><a href="images/1002.png"><img src="images/1002-tn.png" height="225"
    width="400" ></img></a><p>The second receiver is placed.</p></td>
    <td><a href="images/1003.png"><img src="images/1003-tn.png" height="225"
    width="400" ></img></a><p>The third receiver is placed.</p></td>
    <td><a href="images/1004.png"><img src="images/1004-tn.png" height="225"
    width="400" ></img></a><p>The fourth receiver is placed.</p></td>
    <td><a href="images/1005.png"><img src="images/1005-tn.png" height="225"
    width="400" ></img></a><p>The fifth and final receiver is placed.</p></td>
  </tr>
</table>
<p>Some slightly nicer-looking screenshots using different numbers of
transmitters and receivers.</p>
<table>
  <tr>
    <td><a href="images/screenshot4.png"><img src="images/screenshot4-tn.png" height="225"
    width="400" ></img></a><p>30 transmitters, 15 receivers.</p></td>
    <td><a href="images/screenshot1.png"><img src="images/screenshot1-tn.png" height="225"
    width="400" ></img></a><p>20 transmitters, 12 receivers.</p></td>
    <td><a href="images/screenshot2.png"><img src="images/screenshot2-tn.png" height="225"
    width="400" ></img></a><p>15 transmitters, 8 receivers.</p></td>
    <td><a href="images/screenshot3.png"><img src="images/screenshot3-tn.png" height="225"
    width="400" ></img></a><p>10 transmitters, 6 receivers.</p></td>
  </tr>
</table>

<h3>Screenshot Legend</h3>
<ul>
  <li>White "T" - Barely visible unless you look, this is the location of the
  transmitters.</li>
  <li>Blue "R" - This is where a receiver was chosen to be placed.  The number
  next to it indicates how many capture disks contain it. For example, "R80"
  means that the point is contained in 80 capture disks.</li>
  <li>Green Dots - These are the centers and intersection points of the
  capture disks.  These are treated as possible solution points for placing
  receivers, and each one is evaluated.  The ones shown in the screenshots were
  not chosen.</li>
  <li>Red Circles - These are capture disks that don't include any chosen
  receivers.  This is what I was looking for when I wrote the visualization,
  because I wanted to see why the coverage rate was so low even with a lot of
  receivers.</li>
  <li>Yellow Lines - These originate at the receiver locations and terminate
  at the centers of the capture disks that contain the receiver.</li>
</ul>



        </section>

        <aside id="sidebar">
          <a href="https://github.com/romoore/jun-simulate/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/romoore/jun-simulate/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a
          href="https://github.com/romoore/jun-simulate">Pretty Good
          Receiving</a> is maintained by <a
          href="https://github.com/romoore">Robert Moore</a>. Algorithm by
          Junichiro Fukuyama.</p>

          <p>This page was generated by <a href="pages.github.com">GitHub Pages</a> using the Architect theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
